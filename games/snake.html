<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake Game</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1724;
      --accent:#22c55e;
      --muted:#94a3b8;
      --danger:#ef4444;
    }

    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071128 0%, #071b2b 100%);color:#e6eef8}

    .wrap{width:min(920px,95vw);display:grid;grid-template-columns:1fr 320px;gap:20px;padding:28px}
    @media (max-width:880px){.wrap{grid-template-columns:1fr;max-width:680px}}

    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}

    #gameArea{display:flex;align-items:center;justify-content:center}
    canvas{background:linear-gradient(180deg,#051226,#0a2135);border-radius:8px;display:block;max-width:100%;height:auto}

    .panel{width:320px;display:flex;flex-direction:column;gap:12px}
    .panel h2{margin:0;font-size:20px}
    .stats{display:flex;gap:8px;flex-wrap:wrap}
    .stat{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;flex:1;min-width:120px}
    .stat .value{font-size:20px;font-weight:700}
    .controls{display:flex;flex-direction:column;gap:8px}
    button{background:var(--accent);border:none;color:#022;padding:10px 12px;border-radius:8px;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}
    .hint{color:var(--muted);font-size:13px}

    footer{grid-column:1/-1;color:var(--muted);font-size:13px;text-align:center;margin-top:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="gameCard">
      <div id="gameArea">
        <canvas id="gameCanvas" width="600" height="600" tabindex="0"></canvas>
      </div>
    </div>

    <aside class="card panel">
      <h2>Snake — Classic</h2>
      <p class="hint">Use arrow keys or W/A/S/D to control. Space to pause. When you hit the walls you lose.</p>

      <div class="stats">
        <div class="stat">
          <div class="label">Score</div>
          <div id="score" class="value">0</div>
        </div>
        <div class="stat">
          <div class="label">Length</div>
          <div id="length" class="value">1</div>
        </div>
        <div class="stat">
          <div class="label">Speed</div>
          <div id="speed" class="value">1</div>
        </div>
      </div>

      <div class="controls">
        <button id="startBtn">Start / Restart</button>
        <button id="pauseBtn" class="secondary">Pause</button>
        <div class="hint">Tap canvas to focus for keyboard input. On small screens the canvas scales.</div>
      </div>

      <div style="margin-top:8px">
        <div class="label">How it works</div>
        <div class="hint">The game runs on a grid. Each tick moves the snake by one cell. Eating food grows the snake and increases score.</div>
      </div>
    </aside>

    <footer class="hint">Made with love by BackonBITZ.</footer>
  </div>

  <script>
    // Configuration
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const lengthEl = document.getElementById('length');
    const speedEl = document.getElementById('speed');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    // Grid size (cells)
    const COLS = 30;
    const ROWS = 30;
    // Compute cell size from canvas size
    function cellSize(){
      return Math.min(canvas.width / COLS, canvas.height / ROWS);
    }

    // Game state
    let snake = []; // array of {x,y}
    let dir = {x:1,y:0}; // current velocity
    let nextDir = {x:1,y:0};
    let food = null;
    let score = 0;
    let speedLevel = 1; // increments as score increases
    let tickInterval = 120; // ms base
    let lastTick = 0;
    let running = false;
    let paused = false;

    // Initialize or reset game
    function resetGame(){
      snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      placeFood();
      score = 0;
      speedLevel = 1;
      running = true;
      paused = false;
      updateHUD();
    }

    function placeFood(){
      while(true){
        const candidate = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
        if(!snake.some(s => s.x === candidate.x && s.y === candidate.y)){
          food = candidate; break;
        }
      }
    }

    function updateHUD(){
      scoreEl.textContent = score;
      lengthEl.textContent = snake.length;
      speedEl.textContent = speedLevel;
    }

    function growSnake(){
      // we simply don't pop the tail on the next move
      // handled by not slicing when eating - logic implemented in step()
    }

    function step(){
      // update direction (prevent 180-degree turns)
      if((nextDir.x !== -dir.x || nextDir.y !== -dir.y) || snake.length === 1){
        dir = nextDir;
      }

      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // collision with walls -> game over
      if(head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
        gameOver();
        return;
      }

      // collision with self
      if(snake.some(s => s.x === head.x && s.y === head.y)){
        gameOver();
        return;
      }

      // add new head
      snake.unshift(head);

      // did we eat food?
      if(food && head.x === food.x && head.y === food.y){
        score += 10;
        // increase speed every 30 points
        if(score % 30 === 0) speedLevel++;
        placeFood();
      } else {
        // normal move: remove tail
        snake.pop();
      }

      updateHUD();
    }

    function gameOver(){
      running = false;
      paused = false;
      // show a simple alert / overlay
      setTimeout(()=>{
        const again = confirm('Game over — score: ' + score + '\nPlay again?');
        if(again) resetGame();
      }, 10);
    }

    // Rendering
    function draw(){
      const cell = cellSize();
      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // draw grid background subtle
      ctx.fillStyle = '#071a2a';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw food
      if(food){
        ctx.fillStyle = '#ffb86b';
        roundRect(ctx, food.x*cell+1, food.y*cell+1, cell-2, cell-2, 4);
        ctx.fill();
      }

      // draw snake
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        if(i===0) ctx.fillStyle = '#22c55e'; else ctx.fillStyle = '#10b981';
        roundRect(ctx, s.x*cell+1, s.y*cell+1, cell-2, cell-2, 4);
        ctx.fill();
      }

      // draw score in corner
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      ctx.fillRect(8,8,120,34);
      ctx.fillStyle = '#e6eef8';
      ctx.font = '14px system-ui';
      ctx.fillText('Score: ' + score, 16, 30);

      if(!running){
        ctx.fillStyle = 'rgba(2,6,12,0.6)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '32px system-ui';
        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
        ctx.textAlign = 'left';
      }
    }

    function roundRect(ctx,x,y,w,h,r){
      if(w < 2*r) r = w/2;
      if(h < 2*r) r = h/2;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    // Main loop
    function loop(ts){
      if(!lastTick) lastTick = ts;
      const interval = Math.max(40, tickInterval - (speedLevel-1)*10); // speed up with level
      if(running && !paused && (ts - lastTick) >= interval){
        step();
        lastTick = ts;
      }
      draw();
      requestAnimationFrame(loop);
    }

    // input
    window.addEventListener('keydown', e => {
      const k = e.key;
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D',' '].includes(k) || e.keyCode >=37 && e.keyCode <=40){
        e.preventDefault();
      }

      if(k === 'ArrowUp' || k === 'w' || k === 'W') nextDir = {x:0,y:-1};
      if(k === 'ArrowDown' || k === 's' || k === 'S') nextDir = {x:0,y:1};
      if(k === 'ArrowLeft' || k === 'a' || k === 'A') nextDir = {x:-1,y:0};
      if(k === 'ArrowRight' || k === 'd' || k === 'D') nextDir = {x:1,y:0};

      if(k === ' '){
        // toggle pause
        if(running){ paused = !paused; }
        else { resetGame(); }
      }
    });

    // Buttons
    startBtn.addEventListener('click', ()=>{ resetGame(); canvas.focus(); });
    pauseBtn.addEventListener('click', ()=>{ if(running) paused = !paused; canvas.focus(); });

    // Resize canvas to fit CSS while keeping resolution
    function fitCanvas(){
      // we'll keep canvas square and set its internal pixel size for crisp rendering
      const styleW = Math.min(600, Math.floor(window.innerWidth * 0.6));
      const size = Math.min(styleW, 720);
      canvas.style.width = '100%';
      // set actual pixel resolution
      const ratio = window.devicePixelRatio || 1;
      canvas.width = COLS * Math.floor(20 * ratio);
      canvas.height = ROWS * Math.floor(20 * ratio);
      ctx.setTransform(ratio,0,0,ratio,0,0);
    }

    window.addEventListener('resize', fitCanvas);

    // Focus when clicking canvas
    canvas.addEventListener('click', ()=> canvas.focus());

    // Start
    fitCanvas();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
